using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;

namespace Rapidnack.Net
{
	public class GpiodIf : IDisposable
	{
		protected class GpioExtent
		{
			public byte[] Contents { get; set; }
		}


		public class Callback
		{
			public int gpio { get; set; }
			public Action<int, UInt32> f { get; set; }
		}


		#region # public enum

		public enum EError
		{
			pigif_bad_send = -2000,
			pigif_bad_recv = -2001,
			pigif_bad_getaddrinfo = -2002,
			pigif_bad_connect = -2003,
			pigif_bad_socket = -2004,
			pigif_bad_noib = -2005,
			pigif_duplicate_callback = -2006,
			pigif_bad_malloc = -2007,
			pigif_bad_callback = -2008,
			pigif_notify_failed = -2009,
			pigif_callback_not_found = -2010,
			pigif_unconnected_pi = -2011,
			pigif_too_many_pis = -2012,
		}

		#endregion


		#region # event

		public event EventHandler StreamConnected;

		#endregion


		#region # private const

		private const string PI_DEFAULT_SOCKET_PORT_STR = "8888";
		private const string PI_DEFAULT_SOCKET_ADDR_STR = "127.0.0.1";

		private const int PI_MAX_REPORTS_PER_READ = 4096;

		private const int PIGPIOD_IF2_VERSION = 13;

		/*DEF_S Socket Command Codes*/

		private const int PI_CMD_NB = 19;
		private const int PI_CMD_NC = 21;
		private const int PI_CMD_NOIB = 99;

		#endregion


		#region # public const

		/*DEF_S Error Codes*/

		//public const int PI_INIT_FAILED = -1; // gpioInitialise failed
		public const int PI_BAD_USER_GPIO = -2; // GPIO not 0-31
		//public const int PI_BAD_GPIO = -3; // GPIO not 0-53
		//public const int PI_BAD_MODE = -4; // mode not 0-7
		//public const int PI_BAD_LEVEL = -5; // level not 0-1
		//public const int PI_BAD_PUD = -6; // pud not 0-2
		//public const int PI_BAD_PULSEWIDTH = -7; // pulsewidth not 0 or 500-2500
		//public const int PI_BAD_DUTYCYCLE = -8; // dutycycle outside set range
		//public const int PI_BAD_TIMER = -9; // timer not 0-9
		//public const int PI_BAD_MS = -10; // ms not 10-60000
		//public const int PI_BAD_TIMETYPE = -11; // timetype not 0-1
		//public const int PI_BAD_SECONDS = -12; // seconds < 0
		//public const int PI_BAD_MICROS = -13; // micros not 0-999999
		//public const int PI_TIMER_FAILED = -14; // gpioSetTimerFunc failed
		//public const int PI_BAD_WDOG_TIMEOUT = -15; // timeout not 0-60000
		//public const int PI_NO_ALERT_FUNC = -16; // DEPRECATED
		//public const int PI_BAD_CLK_PERIPH = -17; // clock peripheral not 0-1
		//public const int PI_BAD_CLK_SOURCE = -18; // DEPRECATED
		//public const int PI_BAD_CLK_MICROS = -19; // clock micros not 1, 2, 4, 5, 8, or 10
		//public const int PI_BAD_BUF_MILLIS = -20; // buf millis not 100-10000
		//public const int PI_BAD_DUTYRANGE = -21; // dutycycle range not 25-40000
		//public const int PI_BAD_DUTY_RANGE = -21; // DEPRECATED (use PI_BAD_DUTYRANGE)
		//public const int PI_BAD_SIGNUM = -22; // signum not 0-63
		//public const int PI_BAD_PATHNAME = -23; // can't open pathname
		//public const int PI_NO_HANDLE = -24; // no handle available
		//public const int PI_BAD_HANDLE = -25; // unknown handle
		//public const int PI_BAD_IF_FLAGS = -26; // ifFlags > 4
		//public const int PI_BAD_CHANNEL = -27; // DMA channel not 0-14
		//public const int PI_BAD_PRIM_CHANNEL = -27; // DMA primary channel not 0-14
		//public const int PI_BAD_SOCKET_PORT = -28; // socket port not 1024-32000
		//public const int PI_BAD_FIFO_COMMAND = -29; // unrecognized fifo command
		//public const int PI_BAD_SECO_CHANNEL = -30; // DMA secondary channel not 0-6
		//public const int PI_NOT_INITIALISED = -31; // function called before gpioInitialise
		//public const int PI_INITIALISED = -32; // function called after gpioInitialise
		//public const int PI_BAD_WAVE_MODE = -33; // waveform mode not 0-3
		//public const int PI_BAD_CFG_INTERNAL = -34; // bad parameter in gpioCfgInternals call
		//public const int PI_BAD_WAVE_BAUD = -35; // baud rate not 50-250K(RX)/50-1M(TX)
		//public const int PI_TOO_MANY_PULSES = -36; // waveform has too many pulses
		//public const int PI_TOO_MANY_CHARS = -37; // waveform has too many chars
		//public const int PI_NOT_SERIAL_GPIO = -38; // no bit bang serial read on GPIO
		//public const int PI_BAD_SERIAL_STRUC = -39; // bad (null) serial structure parameter
		//public const int PI_BAD_SERIAL_BUF = -40; // bad (null) serial buf parameter
		//public const int PI_NOT_PERMITTED = -41; // GPIO operation not permitted
		//public const int PI_SOME_PERMITTED = -42; // one or more GPIO not permitted
		//public const int PI_BAD_WVSC_COMMND = -43; // bad WVSC subcommand
		//public const int PI_BAD_WVSM_COMMND = -44; // bad WVSM subcommand
		//public const int PI_BAD_WVSP_COMMND = -45; // bad WVSP subcommand
		//public const int PI_BAD_PULSELEN = -46; // trigger pulse length not 1-100
		//public const int PI_BAD_SCRIPT = -47; // invalid script
		//public const int PI_BAD_SCRIPT_ID = -48; // unknown script id
		//public const int PI_BAD_SER_OFFSET = -49; // add serial data offset > 30 minutes
		//public const int PI_GPIO_IN_USE = -50; // GPIO already in use
		//public const int PI_BAD_SERIAL_COUNT = -51; // must read at least a byte at a time
		//public const int PI_BAD_PARAM_NUM = -52; // script parameter id not 0-9
		//public const int PI_DUP_TAG = -53; // script has duplicate tag
		//public const int PI_TOO_MANY_TAGS = -54; // script has too many tags
		//public const int PI_BAD_SCRIPT_CMD = -55; // illegal script command
		//public const int PI_BAD_VAR_NUM = -56; // script variable id not 0-149
		//public const int PI_NO_SCRIPT_ROOM = -57; // no more room for scripts
		//public const int PI_NO_MEMORY = -58; // can't allocate temporary memory
		//public const int PI_SOCK_READ_FAILED = -59; // socket read failed
		//public const int PI_SOCK_WRIT_FAILED = -60; // socket write failed
		//public const int PI_TOO_MANY_PARAM = -61; // too many script parameters (> 10)
		//public const int PI_NOT_HALTED = -62; // DEPRECATED
		//public const int PI_SCRIPT_NOT_READY = -62; // script initialising
		//public const int PI_BAD_TAG = -63; // script has unresolved tag
		//public const int PI_BAD_MICS_DELAY = -64; // bad MICS delay (too large)
		//public const int PI_BAD_MILS_DELAY = -65; // bad MILS delay (too large)
		//public const int PI_BAD_WAVE_ID = -66; // non existent wave id
		//public const int PI_TOO_MANY_CBS = -67; // No more CBs for waveform
		//public const int PI_TOO_MANY_OOL = -68; // No more OOL for waveform
		//public const int PI_EMPTY_WAVEFORM = -69; // attempt to create an empty waveform
		//public const int PI_NO_WAVEFORM_ID = -70; // no more waveforms
		//public const int PI_I2C_OPEN_FAILED = -71; // can't open I2C device
		//public const int PI_SER_OPEN_FAILED = -72; // can't open serial device
		//public const int PI_SPI_OPEN_FAILED = -73; // can't open SPI device
		//public const int PI_BAD_I2C_BUS = -74; // bad I2C bus
		//public const int PI_BAD_I2C_ADDR = -75; // bad I2C address
		//public const int PI_BAD_SPI_CHANNEL = -76; // bad SPI channel
		//public const int PI_BAD_FLAGS = -77; // bad i2c/spi/ser open flags
		//public const int PI_BAD_SPI_SPEED = -78; // bad SPI speed
		//public const int PI_BAD_SER_DEVICE = -79; // bad serial device name
		//public const int PI_BAD_SER_SPEED = -80; // bad serial baud rate
		//public const int PI_BAD_PARAM = -81; // bad i2c/spi/ser parameter
		//public const int PI_I2C_WRITE_FAILED = -82; // i2c write failed
		//public const int PI_I2C_READ_FAILED = -83; // i2c read failed
		//public const int PI_BAD_SPI_COUNT = -84; // bad SPI count
		//public const int PI_SER_WRITE_FAILED = -85; // ser write failed
		//public const int PI_SER_READ_FAILED = -86; // ser read failed
		//public const int PI_SER_READ_NO_DATA = -87; // ser read no data available
		//public const int PI_UNKNOWN_COMMAND = -88; // unknown command
		//public const int PI_SPI_XFER_FAILED = -89; // spi xfer/read/write failed
		//public const int PI_BAD_POINTER = -90; // bad (NULL) pointer
		//public const int PI_NO_AUX_SPI = -91; // no auxiliary SPI on Pi A or B
		//public const int PI_NOT_PWM_GPIO = -92; // GPIO is not in use for PWM
		//public const int PI_NOT_SERVO_GPIO = -93; // GPIO is not in use for servo pulses
		//public const int PI_NOT_HCLK_GPIO = -94; // GPIO has no hardware clock
		//public const int PI_NOT_HPWM_GPIO = -95; // GPIO has no hardware PWM
		//public const int PI_BAD_HPWM_FREQ = -96; // hardware PWM frequency not 1-125M
		//public const int PI_BAD_HPWM_DUTY = -97; // hardware PWM dutycycle not 0-1M
		//public const int PI_BAD_HCLK_FREQ = -98; // hardware clock frequency not 4689-250M
		//public const int PI_BAD_HCLK_PASS = -99; // need password to use hardware clock 1
		//public const int PI_HPWM_ILLEGAL = -100; // illegal, PWM in use for main clock
		//public const int PI_BAD_DATABITS = -101; // serial data bits not 1-32
		//public const int PI_BAD_STOPBITS = -102; // serial (half) stop bits not 2-8
		//public const int PI_MSG_TOOBIG = -103; // socket/pipe message too big
		//public const int PI_BAD_MALLOC_MODE = -104; // bad memory allocation mode
		//public const int PI_TOO_MANY_SEGS = -105; // too many I2C transaction segments
		//public const int PI_BAD_I2C_SEG = -106; // an I2C transaction segment failed
		//public const int PI_BAD_SMBUS_CMD = -107; // SMBus command not supported by driver
		//public const int PI_NOT_I2C_GPIO = -108; // no bit bang I2C in progress on GPIO
		//public const int PI_BAD_I2C_WLEN = -109; // bad I2C write length
		//public const int PI_BAD_I2C_RLEN = -110; // bad I2C read length
		//public const int PI_BAD_I2C_CMD = -111; // bad I2C command
		//public const int PI_BAD_I2C_BAUD = -112; // bad I2C baud rate, not 50-500k
		//public const int PI_CHAIN_LOOP_CNT = -113; // bad chain loop count
		//public const int PI_BAD_CHAIN_LOOP = -114; // empty chain loop
		//public const int PI_CHAIN_COUNTER = -115; // too many chain counters
		//public const int PI_BAD_CHAIN_CMD = -116; // bad chain command
		//public const int PI_BAD_CHAIN_DELAY = -117; // bad chain delay micros
		//public const int PI_CHAIN_NESTING = -118; // chain counters nested too deeply
		//public const int PI_CHAIN_TOO_BIG = -119; // chain is too long
		//public const int PI_DEPRECATED = -120; // deprecated function removed
		//public const int PI_BAD_SER_INVERT = -121; // bit bang serial invert not 0 or 1
		//public const int PI_BAD_EDGE = -122; // bad ISR edge value, not 0-2
		//public const int PI_BAD_ISR_INIT = -123; // bad ISR initialisation
		//public const int PI_BAD_FOREVER = -124; // loop forever must be last command
		//public const int PI_BAD_FILTER = -125; // bad filter parameter
		//public const int PI_BAD_PAD = -126; // bad pad number
		//public const int PI_BAD_STRENGTH = -127; // bad pad drive strength
		//public const int PI_FIL_OPEN_FAILED = -128; // file open failed
		//public const int PI_BAD_FILE_MODE = -129; // bad file mode
		//public const int PI_BAD_FILE_FLAG = -130; // bad file flag
		//public const int PI_BAD_FILE_READ = -131; // bad file read
		//public const int PI_BAD_FILE_WRITE = -132; // bad file write
		//public const int PI_FILE_NOT_ROPEN = -133; // file not open for read
		//public const int PI_FILE_NOT_WOPEN = -134; // file not open for write
		//public const int PI_BAD_FILE_SEEK = -135; // bad file seek
		//public const int PI_NO_FILE_MATCH = -136; // no files match pattern
		//public const int PI_NO_FILE_ACCESS = -137; // no permission to access file
		//public const int PI_FILE_IS_A_DIR = -138; // file is a directory
		//public const int PI_BAD_SHELL_STATUS = -139; // bad shell return status
		//public const int PI_BAD_SCRIPT_NAME = -140; // bad script name
		//public const int PI_BAD_SPI_BAUD = -141; // bad SPI baud rate, not 50-500k
		//public const int PI_NOT_SPI_GPIO = -142; // no bit bang SPI in progress on GPIO
		//public const int PI_BAD_EVENT_ID = -143; // bad event id
		//public const int PI_CMD_INTERRUPTED = -144; // Used by Python

		/*DEF_E*/

		#endregion


		#region # private field

		private bool isConnecting = false;

		private int gPigHandle;

		private CancellationTokenSource cts;

		private Stopwatch sw = new Stopwatch();

		protected Callback[] gCallBackList = new Callback[32];

		//private Dictionary<int, string> errInfo = new Dictionary<int, string>() {
		//   {PI_INIT_FAILED      , "pigpio initialisation failed"},
		//   {PI_BAD_USER_GPIO    , "GPIO not 0-31"},
		//   {PI_BAD_GPIO         , "GPIO not 0-53"},
		//   {PI_BAD_MODE         , "mode not 0-7"},
		//   {PI_BAD_LEVEL        , "level not 0-1"},
		//   {PI_BAD_PUD          , "pud not 0-2"},
		//   {PI_BAD_PULSEWIDTH   , "pulsewidth not 0 or 500-2500"},
		//   {PI_BAD_DUTYCYCLE    , "dutycycle not 0-range (default 255)"},
		//   {PI_BAD_TIMER        , "timer not 0-9"},
		//   {PI_BAD_MS           , "ms not 10-60000"},
		//   {PI_BAD_TIMETYPE     , "timetype not 0-1"},
		//   {PI_BAD_SECONDS      , "seconds < 0"},
		//   {PI_BAD_MICROS       , "micros not 0-999999"},
		//   {PI_TIMER_FAILED     , "gpioSetTimerFunc failed"},
		//   {PI_BAD_WDOG_TIMEOUT , "timeout not 0-60000"},
		//   {PI_NO_ALERT_FUNC    , "DEPRECATED"},
		//   {PI_BAD_CLK_PERIPH   , "clock peripheral not 0-1"},
		//   {PI_BAD_CLK_SOURCE   , "DEPRECATED"},
		//   {PI_BAD_CLK_MICROS   , "clock micros not 1, 2, 4, 5, 8, or 10"},
		//   {PI_BAD_BUF_MILLIS   , "buf millis not 100-10000"},
		//   {PI_BAD_DUTYRANGE    , "dutycycle range not 25-40000"},
		//   {PI_BAD_SIGNUM       , "signum not 0-63"},
		//   {PI_BAD_PATHNAME     , "can't open pathname"},
		//   {PI_NO_HANDLE        , "no handle available"},
		//   {PI_BAD_HANDLE       , "unknown handle"},
		//   {PI_BAD_IF_FLAGS     , "ifFlags > 4"},
		//   {PI_BAD_CHANNEL      , "DMA channel not 0-14"},
		//   {PI_BAD_SOCKET_PORT  , "socket port not 1024-30000"},
		//   {PI_BAD_FIFO_COMMAND , "unknown fifo command"},
		//   {PI_BAD_SECO_CHANNEL , "DMA secondary channel not 0-14"},
		//   {PI_NOT_INITIALISED  , "function called before gpioInitialise"},
		//   {PI_INITIALISED      , "function called after gpioInitialise"},
		//   {PI_BAD_WAVE_MODE    , "waveform mode not 0-1"},
		//   {PI_BAD_CFG_INTERNAL , "bad parameter in gpioCfgInternals call"},
		//   {PI_BAD_WAVE_BAUD    , "baud rate not 50-250K(RX)/50-1M(TX)"},
		//   {PI_TOO_MANY_PULSES  , "waveform has too many pulses"},
		//   {PI_TOO_MANY_CHARS   , "waveform has too many chars"},
		//   {PI_NOT_SERIAL_GPIO  , "no bit bang serial read in progress on GPIO"},
		//   {PI_BAD_SERIAL_STRUC , "bad (null) serial structure parameter"},
		//   {PI_BAD_SERIAL_BUF   , "bad (null) serial buf parameter"},
		//   {PI_NOT_PERMITTED    , "no permission to update GPIO"},
		//   {PI_SOME_PERMITTED   , "no permission to update one or more GPIO"},
		//   {PI_BAD_WVSC_COMMND  , "bad WVSC subcommand"},
		//   {PI_BAD_WVSM_COMMND  , "bad WVSM subcommand"},
		//   {PI_BAD_WVSP_COMMND  , "bad WVSP subcommand"},
		//   {PI_BAD_PULSELEN     , "trigger pulse length not 1-100"},
		//   {PI_BAD_SCRIPT       , "invalid script"},
		//   {PI_BAD_SCRIPT_ID    , "unknown script id"},
		//   {PI_BAD_SER_OFFSET   , "add serial data offset > 30 minute"},
		//   {PI_GPIO_IN_USE      , "GPIO already in use"},
		//   {PI_BAD_SERIAL_COUNT , "must read at least a byte at a time"},
		//   {PI_BAD_PARAM_NUM    , "script parameter id not 0-9"},
		//   {PI_DUP_TAG          , "script has duplicate tag"},
		//   {PI_TOO_MANY_TAGS    , "script has too many tags"},
		//   {PI_BAD_SCRIPT_CMD   , "illegal script command"},
		//   {PI_BAD_VAR_NUM      , "script variable id not 0-149"},
		//   {PI_NO_SCRIPT_ROOM   , "no more room for scripts"},
		//   {PI_NO_MEMORY        , "can't allocate temporary memory"},
		//   {PI_SOCK_READ_FAILED , "socket read failed"},
		//   {PI_SOCK_WRIT_FAILED , "socket write failed"},
		//   {PI_TOO_MANY_PARAM   , "too many script parameters (> 10)"},
		//   {PI_SCRIPT_NOT_READY , "script initialising"},
		//   {PI_BAD_TAG          , "script has unresolved tag"},
		//   {PI_BAD_MICS_DELAY   , "bad MICS delay (too large)"},
		//   {PI_BAD_MILS_DELAY   , "bad MILS delay (too large)"},
		//   {PI_BAD_WAVE_ID      , "non existent wave id"},
		//   {PI_TOO_MANY_CBS     , "No more CBs for waveform"},
		//   {PI_TOO_MANY_OOL     , "No more OOL for waveform"},
		//   {PI_EMPTY_WAVEFORM   , "attempt to create an empty waveform"},
		//   {PI_NO_WAVEFORM_ID   , "no more waveform ids"},
		//   {PI_I2C_OPEN_FAILED  , "can't open I2C device"},
		//   {PI_SER_OPEN_FAILED  , "can't open serial device"},
		//   {PI_SPI_OPEN_FAILED  , "can't open SPI device"},
		//   {PI_BAD_I2C_BUS      , "bad I2C bus"},
		//   {PI_BAD_I2C_ADDR     , "bad I2C address"},
		//   {PI_BAD_SPI_CHANNEL  , "bad SPI channel"},
		//   {PI_BAD_FLAGS        , "bad i2c/spi/ser open flags"},
		//   {PI_BAD_SPI_SPEED    , "bad SPI speed"},
		//   {PI_BAD_SER_DEVICE   , "bad serial device name"},
		//   {PI_BAD_SER_SPEED    , "bad serial baud rate"},
		//   {PI_BAD_PARAM        , "bad i2c/spi/ser parameter"},
		//   {PI_I2C_WRITE_FAILED , "I2C write failed"},
		//   {PI_I2C_READ_FAILED  , "I2C read failed"},
		//   {PI_BAD_SPI_COUNT    , "bad SPI count"},
		//   {PI_SER_WRITE_FAILED , "ser write failed"},
		//   {PI_SER_READ_FAILED  , "ser read failed"},
		//   {PI_SER_READ_NO_DATA , "ser read no data available"},
		//   {PI_UNKNOWN_COMMAND  , "unknown command"},
		//   {PI_SPI_XFER_FAILED  , "spi xfer/read/write failed"},
		//   {PI_BAD_POINTER      , "bad (NULL) pointer"},
		//   {PI_NO_AUX_SPI       , "no auxiliary SPI on Pi A or B"},
		//   {PI_NOT_PWM_GPIO     , "GPIO is not in use for PWM"},
		//   {PI_NOT_SERVO_GPIO   , "GPIO is not in use for servo pulses"},
		//   {PI_NOT_HCLK_GPIO    , "GPIO has no hardware clock"},
		//   {PI_NOT_HPWM_GPIO    , "GPIO has no hardware PWM"},
		//   {PI_BAD_HPWM_FREQ    , "hardware PWM frequency not 1-125M"},
		//   {PI_BAD_HPWM_DUTY    , "hardware PWM dutycycle not 0-1M"},
		//   {PI_BAD_HCLK_FREQ    , "hardware clock frequency not 4689-250M"},
		//   {PI_BAD_HCLK_PASS    , "need password to use hardware clock 1"},
		//   {PI_HPWM_ILLEGAL     , "illegal, PWM in use for main clock"},
		//   {PI_BAD_DATABITS     , "serial data bits not 1-32"},
		//   {PI_BAD_STOPBITS     , "serial (half) stop bits not 2-8"},
		//   {PI_MSG_TOOBIG       , "socket/pipe message too big"},
		//   {PI_BAD_MALLOC_MODE  , "bad memory allocation mode"},
		//   {PI_TOO_MANY_SEGS    , "too many I2C transaction segments"},
		//   {PI_BAD_I2C_SEG      , "an I2C transaction segment failed"},
		//   {PI_BAD_SMBUS_CMD    , "SMBus command not supported by driver"},
		//   {PI_NOT_I2C_GPIO     , "no bit bang I2C in progress on GPIO"},
		//   {PI_BAD_I2C_WLEN     , "bad I2C write length"},
		//   {PI_BAD_I2C_RLEN     , "bad I2C read length"},
		//   {PI_BAD_I2C_CMD      , "bad I2C command"},
		//   {PI_BAD_I2C_BAUD     , "bad I2C baud rate, not 50-500k"},
		//   {PI_CHAIN_LOOP_CNT   , "bad chain loop count"},
		//   {PI_BAD_CHAIN_LOOP   , "empty chain loop"},
		//   {PI_CHAIN_COUNTER    , "too many chain counters"},
		//   {PI_BAD_CHAIN_CMD    , "bad chain command"},
		//   {PI_BAD_CHAIN_DELAY  , "bad chain delay micros"},
		//   {PI_CHAIN_NESTING    , "chain counters nested too deeply"},
		//   {PI_CHAIN_TOO_BIG    , "chain is too long"},
		//   {PI_DEPRECATED       , "deprecated function removed"},
		//   {PI_BAD_SER_INVERT   , "bit bang serial invert not 0 or 1"},
		//   {PI_BAD_EDGE         , "bad ISR edge, not 1, 1, or 2"},
		//   {PI_BAD_ISR_INIT     , "bad ISR initialisation"},
		//   {PI_BAD_FOREVER      , "loop forever must be last chain command"},
		//   {PI_BAD_FILTER       , "bad filter parameter"},
		//   {PI_BAD_PAD          , "bad pad number"},
		//   {PI_BAD_STRENGTH     , "bad pad drive strength"},
		//   {PI_FIL_OPEN_FAILED  , "file open failed"},
		//   {PI_BAD_FILE_MODE    , "bad file mode"},
		//   {PI_BAD_FILE_FLAG    , "bad file flag"},
		//   {PI_BAD_FILE_READ    , "bad file read"},
		//   {PI_BAD_FILE_WRITE   , "bad file write"},
		//   {PI_FILE_NOT_ROPEN   , "file not open for read"},
		//   {PI_FILE_NOT_WOPEN   , "file not open for write"},
		//   {PI_BAD_FILE_SEEK    , "bad file seek"},
		//   {PI_NO_FILE_MATCH    , "no files match pattern"},
		//   {PI_NO_FILE_ACCESS   , "no permission to access file"},
		//   {PI_FILE_IS_A_DIR    , "file is a directory"},
		//   {PI_BAD_SHELL_STATUS , "bad shell return status"},
		//   {PI_BAD_SCRIPT_NAME  , "bad script name"},
		//   {PI_BAD_SPI_BAUD     , "bad SPI baud rate, not 50-500k"},
		//   {PI_NOT_SPI_GPIO     , "no bit bang SPI in progress on GPIO"},
		//   {PI_BAD_EVENT_ID     , "bad event id"},
		//   {PI_CMD_INTERRUPTED  , "command interrupted, Python"},
		//};

		#endregion


		#region # private property

		private TcpConnection TcpConnection { get; set; }

		private TcpConnection NotifyTcpConnection { get; set; }

		#endregion


		#region # public property

		private object _lockObject = new object();
		public object LockObject
		{
			get
			{
				return _lockObject;
			}
		}

		private NetworkStream _commandStream = null;
		public NetworkStream CommandStream
		{
			get
			{
				return _commandStream;
			}
			private set
			{
				_commandStream = value;

				if (CommandStream != null && !isConnecting)
				{
					isConnecting = true;
					if (StreamConnected != null)
					{
						StreamConnected.Invoke(this, new EventArgs());
					}
				}
			}
		}

		private NetworkStream _notifyStream = null;
		public NetworkStream NotifyStream
		{
			get
			{
				return _notifyStream;
			}
			private set
			{
				_notifyStream = value;

				if (CommandStream != null && NotifyStream != null && !isConnecting)
				{
					isConnecting = true;
					if (StreamConnected != null)
					{
						StreamConnected.Invoke(this, new EventArgs());
					}
				}
			}
		}

		public bool IsOpened
		{
			get
			{
				if (this.TcpConnection == null)
					return false;
				return this.TcpConnection.IsOpened;
			}
		}

		public bool CanRead
		{
			get
			{
				if (this.TcpConnection.Stream == null)
					return false;
				return this.TcpConnection.Stream.CanRead;
			}
		}

		public bool CanWrite
		{
			get
			{
				if (this.TcpConnection.Stream == null)
					return false;
				return this.TcpConnection.Stream.CanWrite;
			}
		}

		#endregion


		#region # constructor

		public GpiodIf()
		{
			this.TcpConnection = new TcpConnection();
			this.TcpConnection.StreamChanged += (s, evt) =>
			{
				this.CommandStream = this.TcpConnection.Stream;
			};

			//NotifyTcpConnection = new TcpConnection();
			//NotifyTcpConnection.StreamChanged += (s, evt) =>
			//{
			//	NotifyStream = NotifyTcpConnection.Stream;

			//	if (NotifyTcpConnection.Stream != null)
			//	{
			//		NotifyStream.ReadTimeout = Timeout.Infinite;

			//		gPigHandle = pigpio_notify();

			//		if (gPigHandle >= 0)
			//		{
			//			cts = new CancellationTokenSource();
			//			Task.Run(() => NotifyThread(cts.Token));
			//		}
			//	}
			//};
		}

		#endregion


		#region # Implementation of IDisposable

		bool disposed = false;
		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}
		protected virtual void Dispose(bool disposing)
		{
			if (disposed)
				return;

			if (disposing)
			{
				// Release managed objects
				pigpio_stop();
			}

			// Release unmanaged objects

			disposed = true;
		}
		~GpiodIf()
		{
			Dispose(false);
		}

		#endregion


		#region # public method

		//public string pigpio_error(int errnum)
		//{
		//	if (errnum > -1000)
		//	{
		//		if (errInfo.ContainsKey(errnum))
		//		{
		//			return errInfo[errnum];
		//		}
		//		else
		//		{
		//			return "unknown error";
		//		}
		//	}
		//	else
		//	{
		//		switch ((EError)errnum)
		//		{
		//			case EError.pigif_bad_send:
		//				return "failed to send to pigpiod";
		//			case EError.pigif_bad_recv:
		//				return "failed to receive from pigpiod";
		//			case EError.pigif_bad_getaddrinfo:
		//				return "failed to find address of pigpiod";
		//			case EError.pigif_bad_connect:
		//				return "failed to connect to pigpiod";
		//			case EError.pigif_bad_socket:
		//				return "failed to create socket";
		//			case EError.pigif_bad_noib:
		//				return "failed to open notification in band";
		//			case EError.pigif_duplicate_callback:
		//				return "identical callback exists";
		//			case EError.pigif_bad_malloc:
		//				return "failed to malloc";
		//			case EError.pigif_bad_callback:
		//				return "bad callback parameter";
		//			case EError.pigif_notify_failed:
		//				return "failed to create notification thread";
		//			case EError.pigif_callback_not_found:
		//				return "callback not found";
		//			case EError.pigif_unconnected_pi:
		//				return "not connected to Pi";
		//			case EError.pigif_too_many_pis:
		//				return "too many connected Pis";

		//			default:
		//				return "unknown error";
		//		}
		//	}
		//}

		public UInt32 pigpiod_if_version()
		{
			return PIGPIOD_IF2_VERSION;
		}

		// Do not implement
		//     start_thread() and
		//     stop_thread().

		public int pigpio_start(string addrStr, string portStr)
		{
			if (string.IsNullOrWhiteSpace(addrStr))
			{
				addrStr = PI_DEFAULT_SOCKET_ADDR_STR;
			}
			if (string.IsNullOrWhiteSpace(portStr))
			{
				portStr = PI_DEFAULT_SOCKET_PORT_STR;
			}

			int port;
			if (int.TryParse(portStr, out port) == false)
			{
				return (int)EError.pigif_bad_getaddrinfo;
			}

			isConnecting = false;
			this.TcpConnection.Open(addrStr, port);

			return 0;
		}

		public void pigpio_stop()
		{
			if (cts != null)
			{
				cts.Cancel();
			}

			if (gPigHandle >= 0)
			{
				pigpio_command(PI_CMD_NC, gPigHandle, 0);
				gPigHandle = -1;
			}

			if (this.TcpConnection != null)
			{
				// Execute handlers of StreamChanged event, and call Close()
				this.CommandStream = null;
				this.TcpConnection.Close();
			}
		}

		#endregion


		#region # private method

		private byte[] UInt32ArrayToBytes(UInt32[] array)
		{
			int numBytes = 4;

			byte[] bytes = new byte[numBytes * array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				byte[] tempBytes = BitConverter.GetBytes(array[i]);
				tempBytes.CopyTo(bytes, numBytes * i);
			}

			return bytes;
		}

		protected byte[] UInt32ToBytes(UInt32 data)
		{
			return UInt32ArrayToBytes(new UInt32[] { data });
		}

		protected UInt32[] BytesToUInt32Array(byte[] bytes)
		{
			int numBytes = 4;

			UInt32[] array = new UInt32[bytes.Length / numBytes];
			byte[] dataBytes = new byte[numBytes];
			for (int i = 0; i < array.Length; i++)
			{
				for (int b = 0; b < numBytes; b++)
				{
					dataBytes[b] = bytes[numBytes * i + b];
				}
				array[i] = BitConverter.ToUInt32(dataBytes, 0);
			}

			return array;
		}

		protected int pigpio_command(int command, int p1, int p2)
		{
			if (CanWrite == false || CanRead == false)
			{
				return (int)EError.pigif_unconnected_pi;
			}

			UInt32[] cmd = new UInt32[4];
			cmd[0] = (UInt32)command;
			cmd[1] = (UInt32)p1;
			cmd[2] = (UInt32)p2;
			cmd[3] = 0;

			// UInt32[] -> byte[]
			byte[] bytes = UInt32ArrayToBytes(cmd);

			lock (LockObject)
			{
				try
				{
					this.TcpConnection.Stream.Write(bytes, 0, bytes.Length);
				}
				catch (Exception)
				{
					return (int)EError.pigif_bad_send;
				}

				try
				{
					if (this.TcpConnection.Stream.Read(bytes, 0, bytes.Length) != bytes.Length)
					{
						return (int)EError.pigif_bad_recv;
					}
				}
				catch (Exception)
				{
					return (int)EError.pigif_bad_recv;
				}
			}

			// byte[] -> UInt32[]
			cmd = BytesToUInt32Array(bytes);

			return (int)cmd[2];
		}

		private int pigpio_notify()
		{
			if (NotifyTcpConnection == null || NotifyTcpConnection.Stream == null ||
				NotifyTcpConnection.Stream.CanWrite == false || NotifyTcpConnection.Stream.CanRead == false)
			{
				return (int)EError.pigif_unconnected_pi;
			}

			UInt32[] cmd = new UInt32[4];
			cmd[0] = PI_CMD_NOIB;
			cmd[1] = 0;
			cmd[2] = 0;
			cmd[3] = 0;

			// UInt32[] -> byte[]
			byte[] bytes = UInt32ArrayToBytes(cmd);

			lock (LockObject)
			{
				try
				{
					NotifyTcpConnection.Stream.Write(bytes, 0, bytes.Length);
				}
				catch (Exception)
				{
					return (int)EError.pigif_bad_send;
				}

				try
				{
					if (NotifyTcpConnection.Stream.Read(bytes, 0, bytes.Length) != bytes.Length)
					{
						return (int)EError.pigif_bad_recv;
					}
				}
				catch (Exception)
				{
					return (int)EError.pigif_bad_recv;
				}
			}

			// byte[] -> UInt32[]
			cmd = BytesToUInt32Array(bytes);

			return (int)cmd[2];
		}

		protected int pigpio_command_ext(int command, int p1, int p2, GpioExtent[] exts)
		{
			if (CanWrite == false || CanRead == false)
			{
				return (int)EError.pigif_unconnected_pi;
			}

			int extsBytes = 0;
			foreach (var ext in exts)
			{
				extsBytes += ext.Contents.Length;
			}

			UInt32[] cmd = new UInt32[4];
			cmd[0] = (UInt32)command;
			cmd[1] = (UInt32)p1;
			cmd[2] = (UInt32)p2;
			cmd[3] = (UInt32)extsBytes;

			// UInt32[] -> byte[]
			byte[] cmdBytes = UInt32ArrayToBytes(cmd);

			byte[] bytes = new byte[cmdBytes.Length + extsBytes];
			int index = 0;
			cmdBytes.CopyTo(bytes, index); index += cmdBytes.Length;
			foreach (var ext in exts)
			{
				ext.Contents.CopyTo(bytes, index); index += ext.Contents.Length;
			}

			lock (LockObject)
			{
				try
				{
					this.TcpConnection.Stream.Write(bytes, 0, bytes.Length);
				}
				catch (Exception)
				{
					return (int)EError.pigif_bad_send;
				}

				try
				{
					if (this.TcpConnection.Stream.Read(cmdBytes, 0, cmdBytes.Length) != cmdBytes.Length)
					{
						return (int)EError.pigif_bad_recv;
					}
				}
				catch (Exception)
				{
					return (int)EError.pigif_bad_recv;
				}
			}

			// byte[] -> UInt32[]
			cmd = BytesToUInt32Array(cmdBytes);

			return (int)cmd[2];
		}

		private void NotifyThread(CancellationToken ct)
		{
			byte[] bytes = new byte[8 * PI_MAX_REPORTS_PER_READ];
			int received = 0;

			while (ct.IsCancellationRequested == false)
			{
				if (NotifyTcpConnection == null || NotifyTcpConnection.Stream == null || NotifyTcpConnection.Stream.CanRead == false)
					break;

				try
				{
					while (received < 8)
					{
						received += NotifyTcpConnection.Stream.Read(bytes, received, bytes.Length - received);
					}
				}
				catch (System.IO.IOException)
				{
					break;
				}

				int p = 0;
				while (p + 8 <= received)
				{
					int gpio = (int)BitConverter.ToUInt32(new byte[] { bytes[p + 0], bytes[p + 1], bytes[p + 2], bytes[p + 3] }, 0);
					UInt32 tick = BitConverter.ToUInt32(new byte[] { bytes[p + 4], bytes[p + 5], bytes[p + 6], bytes[p + 7] }, 0);
					if (gCallBackList[gpio] != null)
					{
						var callback = gCallBackList[gpio];
						callback.f(gpio, tick);
					}
					p += 8;
				}
				for (int i = p; i < received; i++)
				{
					bytes[i - p] = bytes[i];
				}
				received -= p;
			}
		}

		protected int intCallback(int user_gpio, Action<int, UInt32> f)
		{
			if ((user_gpio >= 0) && (user_gpio < 32) && f != null)
			{
				/* prevent duplicates */

				//if (gCallBackList[user_gpio] != null)
				//{
				//	return (int)EError.pigif_duplicate_callback;
				//}

				var callback = new Callback()
				{
					gpio = (int)user_gpio,
					f = f
				};
				gCallBackList[user_gpio] = callback;

				return 0;
			}

			return PI_BAD_USER_GPIO;
		}

		protected int intCallback_cancel(int user_gpio)
		{
			if (gCallBackList[user_gpio] != null)
			{
				gCallBackList[user_gpio] = null;
				return 0;
			}
			return (int)EError.pigif_callback_not_found;
		}

		protected int recvMax(byte[] buf, int sent)
		{
			/*
			Copy at most bufSize bytes from the receieved message to
			buf.  Discard the rest of the message.
			*/
			byte[] scratch = new byte[4096];
			int remaining, fetch, count;

			if (sent < buf.Length) count = sent; else count = buf.Length;

			if (count > 0)
			{
				int received = 0;
				while (received < count)
				{
					received += this.TcpConnection.Stream.Read(buf, received, count - received);
				}
			}

			remaining = sent - count;

			while (remaining > 0)
			{
				fetch = remaining;
				if (fetch > scratch.Length) fetch = scratch.Length;
				remaining -= this.TcpConnection.Stream.Read(scratch, 0, fetch);
			}

			return count;
		}

		#endregion
	}
}
